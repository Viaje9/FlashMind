## Context

目前 `study.service.ts` 的 `getStudyCards` 方法回傳固定排序：正向複習 → 反向複習 → 正向新卡 → 反向新卡。使用者希望卡片以隨機順序呈現，同時確保同一張卡片的正反向不會相鄰出現。

現有程式碼在第 261-267 行將四個陣列直接串接回傳，前端則按 `currentIndex` 依序遍歷。

## Goals / Non-Goals

**Goals:**

- 將 `getStudyCards` 回傳的卡片改為隨機混合排序
- 同一張底層卡片的正向與反向 StudyCard 至少間隔 5 張
- 不影響前端邏輯，僅變更後端回傳順序

**Non-Goals:**

- 不提供使用者選擇排序模式的設定（未來可加）
- 不改變卡片選取邏輯（配額計算、篩選條件維持不變）
- 不改變 API 契約（回傳型別不變）

## Decisions

### 1. Shuffle 演算法：Fisher-Yates + 間隔約束後處理

先用 Fisher-Yates 隨機打散所有卡片，再檢查並修正正反向間隔不足的情況。

**替代方案：**
- 建構式方法（邊放邊檢查）：實作複雜度較高，且當卡片總數接近 2×N 時容易卡死
- 加權隨機排序：無法保證硬性的間隔約束

**選擇理由：** Fisher-Yates + 後處理最直觀，容易測試，且在一般卡片數量（數十到數百張）下效能完全足夠。

### 2. 間隔修正策略

Shuffle 後遍歷陣列，當發現同一張卡的正反向間距 < 5 時，將後出現的那張與後方距離足夠的位置交換。若卡片總數不足以滿足間隔 5（例如只有 8 張卡片含正反向），則盡量拉開到最大可能距離（best-effort）。

### 3. 實作位置：獨立純函式

將 shuffle 與間隔約束邏輯抽為純函式（`shuffleWithSpacing`），放在 `study.service.ts` 同模組或獨立檔案中。純函式方便單元測試，不依賴 Prisma 或其他服務。

**函式簽名：**
```typescript
function shuffleWithSpacing(
  cards: StudyCard[],
  minSpacing: number,
): StudyCard[]
```

### 4. 常數 MIN_SPACING = 5

以模組層級常數定義，方便未來調整或改為設定值。

## Risks / Trade-offs

- **[非確定性排序]** → 每次 API 呼叫回傳不同順序。若使用者中途離開再回來會拿到不同順序，但現有的 `startStudy` 流程是一次拿完所有卡片存在前端 store 中，所以不影響學習中的體驗。
- **[間隔無法滿足]** → 當卡片數量太少（例如 ≤ 5 張含正反向）時，無法保證間隔 5。採用 best-effort 策略，盡量拉開。
- **[既有測試需調整]** → 原測試可能斷言固定順序，需改為驗證 shuffle 屬性（包含相同卡片、間隔約束）而非精確順序。
